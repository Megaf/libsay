#!/bin/bash
#
# libsay
# Library that adds the command "say" to print nice looking messages.
# Not only that, it add a bunch of nice functions to the shell or a script.
#
# Author:       Megaf - https://github.com/Megaf - mmegaf [at] gmail [dot] com
# Date:         03/09/2022
# GitHub:       https://github.com/Megaf/libsay
# License:      GPL V3

# source libsay_draw_extensions.say # If included, adds a bunch of commands to draw letters and shapes.

# Repeats arg1 n(arg2) times
symbol_repeat()
{
    local repeat_count="0"
    local repeat_times="$2"
    local symbol="$1"
    while [ "$repeat_count" -lt "$repeat_times" ]; do
        printf '%s' "$symbol"
        local repeat_count="$((++repeat_count))"
    done
    unset -v repeat_count repeat_times symbol
}

# Sets the text foreground and background colour.
set_colour()
{
    # Available colour names.
    local clrs=(
    black red green yellow blue magenta cyan
    white grey
    light_red light_green light_yellow light_blue light_magenta light_cyan
    bright_white
    )

    local chg_clr="printf" # Colour command to be used.
    local clr_arg="$2"

    # Commands to set background colour.
    local clr_cmd_bg=(
    "$chg_clr \e[40m" "$chg_clr \e[41m" "$chg_clr \e[42m" "$chg_clr \e[43m" "$chg_clr \e[44m" "$chg_clr \e[45m" "$chg_clr \e[46m"
    "$chg_clr \e[47m" "$chg_clr \e[100m"
    "$chg_clr \e[101m" "$chg_clr \e[102m" "$chg_clr \e[103m" "$chg_clr \e[104m" "$chg_clr \e[105m" "$chg_clr \e[106m"
    "$chg_clr \e[107m"
    )

    # Commands to set foreground colour.
    local clr_cmd_fg=(
    "$chg_clr \e[30m" "$chg_clr \e[31m" "$chg_clr \e[32m" "$chg_clr \e[33m" "$chg_clr \e[34m" "$chg_clr \e[35m" "$chg_clr \e[36m"
    "$chg_clr \e[37m" "$chg_clr \e[90m"
    "$chg_clr \e[91m" "$chg_clr \e[92m" "$chg_clr \e[93m" "$chg_clr \e[94m" "$chg_clr \e[95m" "$chg_clr \e[96m"
    "$chg_clr \e[97m"
    )

    [ -z "$2" ] && [ "$1" != "fg" -o "$1" != "bg" ] && local clr_arg="$1" # Foreground/cackground arg not passed. Assuming foreground.

    # Checks if the chosen colour is a valid one and then then sets the foreground/background colour.
    for i_search_thing in ${!clrs[@]}; do
        if [[ "${clrs[$i_search_thing]}" == "$clr_arg" ]] && [ "$1" = "fg" ]; then
            ${clr_cmd_fg[$i_search_thing]}
            break
        elif [[ "${clrs[$i_search_thing]}" == "$clr_arg" ]] && [ "$1" = "bg" ]; then
            ${clr_cmd_bg[$i_search_thing]}
            break
        fi
    done

    unset -v clrs chg_clr clr_arg clr_cmd_bg clr_cmd_fg i_search_thing
}

# Set the colour for the border.
set_border_colour()
{
    if [ "$border_colour" ]; then
        set_colour fg "$border_colour"
    fi
}

# Turns text effects on (use rst to reset).
underline_on() { printf "\e[4m"; } # Underlines text.
double_underline_on() { printf "\e[21m"; } # Underlines with double underline.
overline_on() { printf "\e[53m"; } # Overlines text.
overunder_on() { printf "\e[53m\e[4m"; } # Overlines and underlines the text.
bold_on() {  printf "\e[1m"; } # Bold text.
invert_on() { printf "\e[7m"; } # Swap background/foreground colours.
blink_on() { printf "\e[6m"; } # Makes text blink.
italics_on() { printf "\e[3m"; } # Text in italics.
crossout_on() { printf "\e[9m"; } # Crossed out text.
fade_on() { printf "\e[2m"; } # "Fades" text, makes it less intense.

# Message type parse. Colour schemes for these types of message
c_error() { rst; bold_on; underline_on; set_colour bg white; set_colour fg red; } # Set for Error.
c_info() { rst; italics_on; set_colour bg black; set_colour fg green; } # Set for Information.
c_warning() { rst; bold_on; set_colour bg black; set_colour fg light_yellow; } # Set for Warning.
c_debug() { rst; set_colour bg black; set_colour fg cyan; } # Set for Debug.
c_notice() { rst; set_colour bg white; set_colour fg black; } # Set for Notices/Notes.
c_title() { rst; bold_on; double_underline_on; } # Set for Titles.
c_normal() { rst; } # Set for normal text.

# Resets the terminal to the default style.
rst() { printf "\e[0m"; } # Resets all colour and formating  settings.

# Draw function and commands. Used to "draw" borders and dynamic spaces, lines and margins.
draw()
{
    [ ! "$style" ] && local style="boxdoubleline"
    local prnt_args="%s" # Command args to use in the "print" command.
    prnt() { printf "$prnt_args" "$*"; } # "print" command the script uses. In theory it will be easy to use other things than "printf".
    local dynmc_cmd="do_" # Set this string as a "dynamic command", instead of printing a symbol in the array, it will execute an action.

    # Array with valid options for draw command.
    local parts_cmds=(
    topleftcorner top toprightcorner
    leftside rightside
    leftside_c rightside_c
    bottomleftcorner bottom bottomrightcorner
    line do_space do_godown do_save_pos do_go_pos
    do_linefill do_margin do_autofill
    do_topfill do_bottomfill
    )

    # Styles, parts array will be selected according the what's set in '$style'
    # source libsay_extra_styles.say # If inclided, adds more border/line styles.
    # boxdoubleline
    [ "$style" = "boxdoubleline" ] && local parts=(
    ╔ ═ ╗
    ║ ║
    ╠ ╣
    ╚ ═ ╝
    ═
    )

    # boxverticalsinglehorizontaldouble
    [ "$style" = "boxverticalsinglehorizontaldouble" ] && local parts=(
    ╒ ═ ╕
    │ │
    ├ ┤
    ╘ ═ ╛
    ─
    )

    # boxverticaldoublehorizontalsingle
    [ "$style" = "boxverticaldoublehorizontalsingle" ] && local parts=(
    ╓ ─ ╖
    ║ ║
    ╠ ╣
    ╙ ─ ╜
    ─
    )

    # boxsingleline
    [ "$style" = "boxsingleline" ] && local parts=(
    ┌ ─ ┐
    │ │
    ├ ┤
    └ ─ ┘
    ─
    )

    # boxsolid
    [ "$style" = "boxsolid" ] && local parts=(
    █ ▀ █
    █ █
    █ █
    █ ▄ █
    ▄
    )

    # Dynamic draw commands.
    do_linefill() { symbol_repeat "${parts[10]}" "$linesize"; }
    do_topfill() { symbol_repeat "${parts[1]}" "$linesize"; }
    do_bottomfill() { symbol_repeat "${parts[8]}" "$linesize"; }
    do_autofill() { symbol_repeat " " "$border_space"; }
    do_margin() { symbol_repeat " " "$margin"; }
    do_space() { printf "%0.s "; }
    do_godown() { printf "\n"; }

    # Array that contains the commands that are executed with "do_commands", like "do_margin"
    local dynmc_cmds=(
    "0" "0" "0"
    "0" "0"
    "0" "0"
    "0" "0" "0"
    "0" "do_space" "do_godown" "do_save_pos" "do_go_pos"
    "do_linefill" "do_margin" "do_autofill"
    "do_topfill" "do_bottomfill"
    )

    # 'for loop' to check if the required symbol is a static or a dynamic symbol.
    for i_search_thing in "$@"; do
        local part_index="0"
        for n_part_cmd in "${parts_cmds[@]}"; do
            if [ ! "$n_part_cmd" = "$i_search_thing" ]; then
                part_index="$((++part_index))"
            elif [ "$n_part_cmd" = "$i_search_thing" ]; then
                if [[ "${parts_cmds[$part_index]}" == "$dynmc_cmd"*  ]]; then
                    "${dynmc_cmds[$part_index]}"
                else
                    prnt "${parts[$part_index]}"
                fi
                unset part_index
                break
            fi
        done
    done

    unset -v style prnt_args dynmc_cmd parts_cmds parts dynmc_cmds i_search_thing part_index
    unset -f prnt do_linefill do_topfill do_bottomfill do_margin do_autofill do_space do_godown
}

say()
{
    unset msg
    check_options()
    {
        [ "$1" = "colour_command" ] && local options=( --colour --color )
        [ "$1" = "alignment_command" ] && local options=( --align )
        [ "$1" = "colour" ] && local options=(black red green yellow blue magenta cyan
        white grey light_red light_green light_yellow light_blue light_magenta light_cyan
        bright_white bright_black
        )
        [ "$1" = "alignment" ] && local options=( centre center left right )

        for i_search_thing in "${options[@]}"; do
            [ "$i_search_thing" = "$2" ] && return 3
        done
        unset -v options
    }

    validade_command()
    {
        for i_search_thing in "$*"; do
            check_options colour_command "$1"
            if [ "$?" = 3 ]; then
                check_options colour "$2"
                if [ "$?" = 3 ]; then
                    colour="$2"; shift 2
                else
                    shift 2
                fi
            fi

            check_options alignment_command "$1"
            if [ "$?" = 3 ]; then
                check_options alignment "$2"
                if [ "$?" = 3 ]; then
                    align="$2"; shift 2
                else
                    shift 2
                fi
            fi

            check_options colour_command "$1"; colour_result="$?"
            check_options alignment_command $1; align_result="$?"
            if [ "$colour_result" = 0 ] && [ "$align_result" = 0 ]; then
                if [[ "$1" == "--"* ]]; then
                    shift 1
                fi
            fi

            # If no command line arg was passed and the user doesn't want to open a txt file...
            if [[ ! "$1" == "--"* ]] && [[ ! "$1" == *".txt" ]]; then
                msg="$*" # ...Then grabs the whole input line as the text to use.
            fi
        done
        unset args
    }

    local args=( "$@" )
    validade_command "${args[@]}"

    # Checks if input is coming from the standard input.
    if [ ! -t 0 ]; then
        msg="$(cat)"
    elif [[ "$1" == *".txt" ]]; then # Or if it's coming from a text file.
        msg="$(cat $1)"
    fi

    # Function that will read text in '$msg' and find how long is the longest line.
    find_longest_line()
    {
        local line_length="0"
        local line_content=""
        while IFS= read -r line_content; do # Reading line by line.
            if [[ "$line_content" == "TITLE:"* ]]; then # "Titles" Are printed without "TITLE: ", so remove it from the column count.
                local line_content="${line_content:7}"
            fi
            if (( "${#line_content}" >= "$line_length" )); then # Checks if line read is longest than the previous.
                local line_length="${#line_content}" # If it is, get's the number of columns and set it to a variable.
            fi
       done <<< $msg
       printf "%s$line_length"
       unset -v line_content line_length
    }

    local longest_line="$(find_longest_line)" # Length of the longest line in the text.
    unset -f find_longest_line
    local margin="1" # Default margin size between the side of the box and text.
    local spacesize="3" # Basically adjust the amount of space on both sides of the text to the box.
    local minimal_size="10" # Box will not be smaller than this, no matter how little the text is.
    if (( "$longest_line" <= "$minimal_size" )); then
        local linesize="$minimal_size" # If the longest line is shorter than minimal_size, then minimal_size will become the length.
    elif (( "$longest_line" > "$minimal_size" )); then
        local linesize="$((longest_line+spacesize))" # Otherwise, line length + space after the border will be the length.
    fi

    # Draws the top of the box
    set_border_colour; draw topleftcorner do_topfill toprightcorner do_godown

    # While loop that brakes the whole text in individual lines for processing and printing.
    while IFS= read -r text_line; do

        # This loop runs, for each line, calculations and printing.
        text_in_a_box()
        {
            # Formats the text according to first keyword on each line
            apply_text_effect()
            {
                # Checks if the line contain any of these works and apply colour code.
                if [[ "$text_line" == "ERROR:"* ]] || [[ "$text_line" == "ERR:"* ]]; then
                    c_error
                elif [[ "$text_line" == "INFO:"* ]]; then
                    c_info
                elif [[ "$text_line" == "WARN:"* ]] || [[ "$text_line" == "WARNING:"* ]]; then
                    c_warning
                elif [[ "$text_line" == "DEBUG:"* ]] || [[ "$text_line" == "DBG:"* ]] || [[ "$text_line" == "ADV_DBG:"* ]]; then
                    c_debug
                elif [[ "$text_line" == "NOTICE:"* ]] || [[ "$text_line" == "NOTE:"* ]]; then
                    c_notice
                elif [[ "$text_line" == "TITLE:"* ]]; then
                    c_title
                else
                    set_colour fg "$1"
                    [ "$weight" = "bold" -o "$2" = "bold" ] && bold_on
                fi
            }

            # Final loop, calculates the line and spaces size and then prints the line.
            write_out()
            {
                local txt_size="${#4}"
                local border_space="$((linesize-(txt_size+margin)))" # Longest space between text and border.

                centre_text()
                {
                    # Calculates the space before and after the text so the text is centrered.
                    local space_left="$(((linesize/ 2)-(txt_size/2)))"; local space_right="$((linesize-(space_left+txt_size)))"
                    symbol_repeat " " "$space_left"
                    apply_text_effect "$2" "$3"
                    printf '%s' "$1"
                    rst
                    symbol_repeat " " "$space_right" # Adds empty space, print text and adds space.
                    unset -v space_left space_right
                }

                align_text_left()
                {
                    draw do_margin
                    apply_text_effect "$2" "$3"
                    printf '%s' "$1"
                    rst
                    draw do_autofill
                }

                align_text_right()
                {
                    draw do_autofill
                    apply_text_effect "$2" "$3"
                    printf '%s' "$1"
                    rst
                    draw do_margin
                }

                rst
                [ "$1" = "centre" -o "$1" = "center" ] && centre_text "$4" "$3" "$2" # Centres text.
                [ "$1" = "left" ] || [ -z "$1" ] && align_text_left "$4" "$3" "$2" # Aligns to the left.
                [ "$1" = "right" ] && align_text_right "$4" "$3" "$2" # Aligns to the right.
                rst

                unset -v border_space txt_size
            }

            set_border_colour
            [ ! "$text_line" ] && draw leftside_c do_linefill || draw leftside # If not an empty line, draws the left border. If empty, fill it with a line and draws a border that connects with the line.
            if [ "$text_line" ]; then
                if [[ "$text_line" == "TITLE:"* ]]; then # Removes "TITLE: " from "TITLE: " containing lines.
                    local no_title_text_line="${text_line:7}"
                    write_out "$align" "$weight" "$colour" "$no_title_text_line" # Formats and prints the line of text if the line is not empty.
                else
                    write_out "$align" "$weight" "$colour" "$text_line" # Formats and prints the line of text if the line is not empty.
                fi
            fi
            set_border_colour
            [ ! "$text_line" ] && draw rightside_c do_godown || draw rightside do_godown # If not an empty line, draws the right straight border. If empty, draws a border that conencts with a line.
        }

        # Only prints a line, if either the line doesn't contain debug of if debug is enabled.
        if [ ! "$debug" = "true" ] && [[ ! "$text_line" =~ "DEBUG:"* ]]; then
            text_in_a_box
        elif [ "$debug" = "true" ]; then
            text_in_a_box
        fi

    done <<< $msg

    # Draws the bottom of the box
    set_border_colour; draw bottomleftcorner do_bottomfill bottomrightcorner do_godown

    unset -v msg colour_result align_result align colour i_search_thing n_part_cmd p_search_thing margin spacesize minimal_size longest_line linesize text_line weight border_colour
    unset -f text_in_a_box write_out apply_text_effect centre_text align_text_left align_text_right
}

