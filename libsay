#!/bin/bash
#
# libsay - Version: 1.2-202209.26.180000
# Library that adds the command "say" to print nice looking messages.
# Not only that, it add a bunch of nice functions to the shell or a script.
#
# Author:       Megaf - https://github.com/Megaf - mmegaf [at] gmail [dot] com
# Date:         03/09/2022
# GitHub:       https://github.com/Megaf/libsay
# License:      GPL V3

# Repeats arg1 n(arg2) times
symbol_repeat()
{
    local repeat_count="0"
    local repeat_times="$2"
    local symbol="$1"
    while [ "$repeat_count" -lt "$repeat_times" ]; do
        printf '%s' "$symbol"
        local repeat_count="$((++repeat_count))"
    done
    unset -v repeat_count repeat_times symbol
}

# Sets the text foreground and background colour.
set_colour()
{
    # Available colour names.
    local clrs=(
    black red green yellow blue magenta cyan
    white grey
    light_red light_green light_yellow light_blue light_magenta light_cyan
    bright_white
    )

    local chg_clr="printf" # Colour command to be used.
    local clr_arg="$2"

    # Commands to set background colour.
    local clr_cmd_bg=(
    "$chg_clr \e[40m" "$chg_clr \e[41m" "$chg_clr \e[42m" "$chg_clr \e[43m" "$chg_clr \e[44m" "$chg_clr \e[45m" "$chg_clr \e[46m"
    "$chg_clr \e[47m" "$chg_clr \e[100m"
    "$chg_clr \e[101m" "$chg_clr \e[102m" "$chg_clr \e[103m" "$chg_clr \e[104m" "$chg_clr \e[105m" "$chg_clr \e[106m"
    "$chg_clr \e[107m"
    )

    # Commands to set foreground colour.
    local clr_cmd_fg=(
    "$chg_clr \e[30m" "$chg_clr \e[31m" "$chg_clr \e[32m" "$chg_clr \e[33m" "$chg_clr \e[34m" "$chg_clr \e[35m" "$chg_clr \e[36m"
    "$chg_clr \e[37m" "$chg_clr \e[90m"
    "$chg_clr \e[91m" "$chg_clr \e[92m" "$chg_clr \e[93m" "$chg_clr \e[94m" "$chg_clr \e[95m" "$chg_clr \e[96m"
    "$chg_clr \e[97m"
    )

    [ -z "$2" ] && [ "$1" != "fg" ] && [ "$1" != "bg" ] && local clr_arg="$1" # Foreground/cackground arg not passed. Assuming foreground.

    # Checks if the chosen colour is a valid one and then then sets the foreground/background colour.
    for i_search_thing in "${!clrs[@]}"; do
        if [[ "${clrs[$i_search_thing]}" == "$clr_arg" ]] && [ "$1" = "fg" ]; then
            ${clr_cmd_fg[$i_search_thing]}
            break
        elif [[ "${clrs[$i_search_thing]}" == "$clr_arg" ]] && [ "$1" = "bg" ]; then
            ${clr_cmd_bg[$i_search_thing]}
            break
        fi
    done

    unset -v clrs chg_clr clr_arg clr_cmd_bg clr_cmd_fg i_search_thing
}

# Set the colour for the border.
set_border_colour() { rst; [ "$border_colour" ] && set_colour fg "$border_colour"; }

# Turns text effects on (use rst to reset).
underline_on() { printf "\e[4m"; } # Underlines text.
underline_off() { printf "\e[24m"; } # Disables (wavy)underline text.
wavy_underline_on() { printf "\e[4:3m"; } # Underlines text with a squiggly underline.
double_underline_on() { printf "\e[21m"; } # Underlines with double underline.
overline_on() { printf "\e[53m"; } # Overlines text.
overunder_on() { printf "\e[53m\e[4m"; } # Overlines and underlines the text.
overuwavynder_on() { printf "\e[53m\e[4:3m"; } # Overlines and squiggly underlines the text.

bold_on() {  printf "\e[1m"; } # Bold text.
bold_off() { printf "\e[22m"; } # Turns bold and fade/dim text off.
fade_on() { printf "\e[2m"; } # Dims text.
fade_off() { printf "\e[22m"; } # Turns bold and fade/dim text off.

invert_on() { printf "\e[7m"; } # Swap background/foreground colours.
invert_off() { printf "\e[27m"; } # Swap back background/foreground colours.
blink_on() { printf "\e[6m"; } # Makes text blink.
blink_off() { printf "\e[25m"; } # Makes text stop blinking.

italics_on() { printf "\e[3m"; } # Text in italics.
italics_off() { printf "\e[23m"; } # Turns italics off.
crossout_on() { printf "\e[9m"; } # Crossed out text.
crossout_off() { printf "\e[29m"; } # Turns off crossed out text.

fg_colour_off() { printf "\e[39m"; } # Set's foreground colour back to default.
bg_colour_off() { printf "\e[49m"; } # Set's background colour back to default.

# Text manipulation/cursor navigation.
backspace() { printf "\b"; } # Deletes last character.
tab() { printf "\t"; } # Inserts a tab.
newline() { printf "\n"; } # Goes to the next line, "enter".
v_tab() { printf "\v"; } # Adds a vertical tab.
reset_line() { printf "\r"; } # Goes to the beginning of the line allows to add new text over the last text.
clear_screen() { printf "\ec"; } # Clears the whole screen, similar to "clear".

cursor_up() { printf "\e[1A"; } # Moves cursor one line up.
cursor_down() { printf "\e[B"; } # Moves cursor one line down.
cursor_right() { printf "\e[1C"; } # Moves cursor one column right.
cursor_left() { printf "\e[1D"; } # Moves cursor one column left.
save_pos() { printf "\e[s"; } # Save cursor's current position.
restore_pos() { printf "\e[u"; } # Restore cursor's to saved position.

# Message type parse. Colour schemes for these types of message
c_error() { rst; bold_on; underline_on; set_colour bg white; set_colour fg red; } # Set for Error.
c_info() { rst; italics_on; set_colour bg black; set_colour fg green; } # Set for Information.
c_warning() { rst; bold_on; set_colour bg black; set_colour fg light_yellow; } # Set for Warning.
c_debug() { rst; set_colour bg black; set_colour fg cyan; } # Set for Debug.
c_notice() { rst; set_colour bg white; set_colour fg black; } # Set for Notices/Notes.
c_title() { rst; bold_on; double_underline_on; } # Set for Titles.
c_normal() { rst; } # Set for normal text.

# Resets the terminal to the default style.
rst() { printf "\e[0m"; } # Resets all colour and formating  settings.

# Draw function and commands. Used to "draw" borders and dynamic spaces, lines and margins.
draw()
{
    [ -z "$style" ] && local style="boxdoubleline"
    prnt() { rst; set_border_colour; printf '%s' "$*"; rst; } # "print" command the script uses. In theory it will be easy to use other things than "printf".
    local dynmc_cmd="do_" # Set this string as a "dynamic command", instead of printing a symbol in the array, it will execute an action.

    # Array with valid options for draw command.
    local parts_cmds=(
    topleftcorner top toprightcorner
    leftside rightside column
    leftside_c rightside_c
    bottomleftcorner bottom bottomrightcorner
    line bottom_c top_c
    junction
    do_space do_godown
    do_linefill do_margin do_autofill
    do_topfill do_bottomfill
    )

    # Styles, parts array will be selected according the what's set in '$style'
    # Uncomment line below to add custom styles.
    # source styles/*.style.say

    # boxdoubleline
    [ "$style" = "boxdoubleline" ] && local parts=(
    ╔ ═ ╗
    ║ ║ ║
    ╠ ╣
    ╚ ═ ╝
    ═ ╩ ╦
    ╬
    )

    # boxverticalsinglehorizontaldouble
    [ "$style" = "boxverticalsinglehorizontaldouble" ] && local parts=(
    ╒ ═ ╕
    │ │ ║
    ├ ┤
    ╘ ═ ╛
    ─ ╩ ╦
    ┼
    )

    # boxverticaldoublehorizontalsingle
    [ "$style" = "boxverticaldoublehorizontalsingle" ] && local parts=(
    ╓ ─ ╖
    ║ ║ │
    ╠ ╣
    ╙ ─ ╜
    ─ ┴ ┬
    ┼
    )

    # boxsingleline
    [ "$style" = "boxsingleline" ] && local parts=(
    ┌ ─ ┐
    │ │ │
    ├ ┤
    └ ─ ┘
    ─ ┴ ┬
    ┼
    )

    # boxsolid
    [ "$style" = "boxsolid" ] && local parts=(
    █ ▀ █
    █ █ █
    █ █
    █ ▄ █
    ▄ █ █
    █
    )

    # Dynamic draw commands.
    do_linefill() { rst; set_border_colour; symbol_repeat "${parts[11]}" "$linesize"; }
    do_topfill() { rst; set_border_colour; symbol_repeat "${parts[1]}" "$linesize"; }
    do_bottomfill() { rst; set_border_colour; symbol_repeat "${parts[9]}" "$linesize"; }
    do_autofill() { symbol_repeat " " "$border_space"; }
    do_margin() { symbol_repeat " " "$margin"; }
    do_space() { printf " "; }
    do_godown() { printf "\n"; }

    # Array that contains the commands that are executed with "do_commands", like "do_margin"
    local dynmc_cmds=(
    "0" "0" "0"
    "0" "0" "0"
    "0" "0"
    "0" "0" "0"
    "0" "0" "0"
    "0"
    "do_space" "do_godown"
    "do_linefill" "do_margin" "do_autofill"
    "do_topfill" "do_bottomfill"
    )

    # 'for loop' to check if the required symbol is a static or a dynamic symbol.
    for i_search_thing in "$@"; do
        local part_index="0"
        for n_part_cmd in "${parts_cmds[@]}"; do
            if [ ! "$n_part_cmd" = "$i_search_thing" ]; then
                part_index="$((++part_index))"
            elif [ "$n_part_cmd" = "$i_search_thing" ]; then
                if [[ "${parts_cmds[$part_index]}" == "$dynmc_cmd"*  ]]; then
                    "${dynmc_cmds[$part_index]}"
                else
                    prnt "${parts[$part_index]}"
                fi
                unset part_index
                break
            fi
        done
    done

    unset -v prnt_args dynmc_cmd parts_cmds parts dynmc_cmds i_search_thing part_index
    unset -f prnt do_linefill do_topfill do_bottomfill do_margin do_autofill do_space do_godown
}

say()
{
    unset -v msg
    [ -z "$weight" ] && weight=""
    [ -z "$border_colour" ] && border_colour=""
    [ -z "$debug" ] && debug=""

    check_options()
    {
        [ "$1" = "colour_command" ] && local options=( --colour --color )
        [ "$1" = "alignment_command" ] && local options=( --align )
        [ "$1" = "colour" ] && local options=( black red green yellow blue magenta cyan white
        grey light_red light_green light_yellow light_blue light_magenta light_cyan bright_white )
        [ "$1" = "alignment" ] && local options=( centre center left right )

        for i_search_thing in "${options[@]}"; do
            [ "$i_search_thing" = "$2" ] && return 3
        done
        unset -v options
    }

    validade_command()
    {
        for i_search_thing in "$@"; do
            check_options colour_command "$1"
            if [ "$?" = 3 ]; then
                check_options colour "$2"
                if [ "$?" = 3 ]; then
                    colour="$2"; shift 2
                else
                    shift 2
                fi
            fi

            check_options alignment_command "$1"
            if [ "$?" = 3 ]; then
                check_options alignment "$2"
                if [ "$?" = 3 ]; then
                    align="$2"; shift 2
                else
                    shift 2
                fi
            fi

            check_options colour_command "$1"; colour_result="$?"
            check_options alignment_command "$1"; align_result="$?"
            if [ "$colour_result" = 0 ] && [ "$align_result" = 0 ]; then
                if [[ "$1" == "--"* ]]; then
                    shift 1
                fi
            fi

            # If no command line arg was passed and the user doesn't want to open a txt file...
            if [[ ! "$1" == "--"* ]] && [[ ! "$1" == *".txt" ]]; then
                msg="$*" # ...Then grabs the whole input line as the text to use.
            fi
        done
        unset args
    }

    local args=( "$@" )
    validade_command "${args[@]}"

    # Checks if input is coming from the standard input.
    if [ ! -t 0 ]; then
        msg="$(cat)"
    elif [[ "$*" == *".txt"* ]]; then
        local arguments=( "$@"  )
        for text_file in "${arguments[@]}"; do
            if [[ "$text_file" == *".txt" ]]; then
                msg="$(cat "$text_file")"
                unset -v text_file arguments
                break
            fi
        done
        unset -v text_file arguments
    fi

    do_work()
    {
        # Function that will read text in '$msg' and find how long is the longest line.
        find_longest_line()
        {
            local line_length="0"
            local line_content=""
            while IFS= read -r line_content; do # Reading line by line.
                if [[ "$line_content" == "TITLE:"* ]]; then # "Titles" Are printed without "TITLE: ", so remove it from the column count.
                    local line_content="${line_content//TITLE: /}"
                fi
                if (( "${#line_content}" >= "$line_length" )); then # Checks if line read is longest than the previous.
                    local line_length="${#line_content}" # If it is, get's the number of columns and set it to a variable.
                fi
           done <<< "$msg"
           printf "%s$line_length"
           unset -v line_content line_length
        }


        local longest_line
        longest_line="$(find_longest_line)" # Length of the longest line in the text.
        unset -f find_longest_line
        local margin="0" # Default margin size between the side of the box and text.
        local spacesize="1" # Basically adjust the amount of space on both sides of the text to the box.
        local minimal_size="10" # Box will not be smaller than this, no matter how little the text is.
        if (( "$longest_line" <= "$minimal_size" )); then
            local linesize="$minimal_size" # If the longest line is shorter than minimal_size, then minimal_size will become the length.
        elif (( "$longest_line" > "$minimal_size" )); then
            local linesize="$((longest_line+spacesize))" # Otherwise, line length + space after the border will be the length.
        fi

        # Draws the top of the box
        draw topleftcorner do_topfill toprightcorner do_godown

        # While loop that brakes the whole text in individual lines for processing and printing.
        while IFS= read -r text_line; do

            # This loop runs, for each line, calculations and printing.
            text_in_a_box()
            {
                # Formats the text according to first keyword on each line
                apply_text_effect()
                {
                    # Checks if the line contain any of these works and apply colour code.
                    if [[ "$text_line" == "ERROR:"* ]] || [[ "$text_line" == "ERR:"* ]]; then
                        c_error
                    elif [[ "$text_line" == "INFO:"* ]]; then
                        c_info
                    elif [[ "$text_line" == "WARN:"* ]] || [[ "$text_line" == "WARNING:"* ]]; then
                        c_warning
                    elif [[ "$text_line" == "DEBUG:"* ]] || [[ "$text_line" == "DBG:"* ]] || [[ "$text_line" == "ADV_DBG:"* ]]; then
                        c_debug
                    elif [[ "$text_line" == "NOTICE:"* ]] || [[ "$text_line" == "NOTE:"* ]]; then
                        c_notice
                    elif [[ "$text_line" == "TITLE:"* ]]; then
                        c_title
                    else
                        set_colour fg "$1"
                        [ "$weight" = "bold" ] || [ "$2" = "bold" ] && bold_on
                    fi
                }

                # Final loop, calculates the line and spaces size and then prints the line.
                write_out()
                {
                    local txt_size="${#4}"
                    local border_space="$((linesize-(txt_size+margin)))" # Longest space between text and border.

                    centre_text()
                    {
                        # Calculates the space before and after the text so the text is centrered.
                        local space_left="$(((linesize/ 2)-(txt_size/2)))"; local space_right="$((linesize-(space_left+txt_size)))"
                        symbol_repeat " " "$space_left"
                        apply_text_effect "$2" "$3"
                        printf '%s' "$1"
                        rst
                        symbol_repeat " " "$space_right" # Adds empty space, print text and adds space.
                        unset -v space_left space_right
                    }

                    align_text_left()
                    {
                        draw do_margin
                        apply_text_effect "$2" "$3"
                        printf '%s' "$1"
                        rst
                        draw do_autofill
                    }

                    align_text_right()
                    {
                        draw do_autofill
                        apply_text_effect "$2" "$3"
                        printf '%s' "$1"
                        rst
                        draw do_margin
                    }

                    rst
                    [ "$1" = "centre" ] || [ "$1" = "center" ] && centre_text "$4" "$3" "$2" # Centres text.
                    [ "$1" = "left" ] || [ -z "$1" ] && align_text_left "$4" "$3" "$2" # Aligns to the left.
                    [ "$1" = "right" ] && align_text_right "$4" "$3" "$2" # Aligns to the right.
                    rst

                    unset -v border_space txt_size
                }

                # If not an empty line, draws the left border. If empty, fill it with a line and draws a border that connects with the line.
                [ -z "$text_line" ] && draw leftside_c do_linefill
                [ "$text_line" ] && draw leftside
                if [ "$text_line" ]; then
                    if [[ "$text_line" == "TITLE:"* ]]; then # Removes "TITLE: " from "TITLE: " containing lines.
                        local no_title_text_line="${text_line//TITLE: /}"
                        write_out "centre" "$weight" "$colour" "$no_title_text_line" # Formats and prints the line of text if the line is not empty.
                    else
                        write_out "$align" "$weight" "$colour" "$text_line" # Formats and prints the line of text if the line is not empty.
                    fi
                fi
                # If not an empty line, draws the right straight border. If empty, draws a border that conencts with a line.
                [ -z "$text_line" ] && draw rightside_c do_godown
                [ "$text_line" ] && draw rightside do_godown
            }

            # Only prints a line, if either the line doesn't contain debug of if debug is enabled.
            if [ ! "$debug" = "true" ] && [[ ! "$text_line" == "DEBUG:"* ]]; then
                text_in_a_box
            elif [ "$debug" = "true" ]; then
                text_in_a_box
            fi

        done <<< "$msg"

        # Draws the bottom of the box
        draw bottomleftcorner do_bottomfill bottomrightcorner do_godown
    }

    # Only run "do_work" if text/string is not empty and if string doesn't "contain DEBUG" or "debug=true".
    if [ ! -d "$msg" ] && [ ! "$msg" = "" ]; then
        if [ ! "$debug" = "true" ] && [[ ! "$msg" == "DEBUG:"* ]]; then
            do_work
        elif [ "$debug" = "true" ]; then
            do_work
        else
            return 0
        fi
    else
        return 0
    fi

    unset -v style msg colour_result align_result align colour i_search_thing n_part_cmd p_search_thing margin spacesize minimal_size longest_line linesize text_line weight border_colour
    unset -f text_in_a_box write_out apply_text_effect centre_text align_text_left align_text_right
    return 0
}
